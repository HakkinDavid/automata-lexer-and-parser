<programa> -> <librerías> <espacio_nombres> <declaración_compuesta> <función_principal> <funciones>

Arriba del main---------------------------------------------------------------------------------------------

<librerías> -> #include <nombre_librería> <librerías> | ε

<nombre_librería> -> <<nombre>.h> 
                    | "<nombre>.h"

<espacio_nombres> -> using namespace std; 
                    | ε

<declaración_compuesta> -> struct <nombre> <herencia> { <miembros_struct> }
                         | class <nombre> <herencia> { <miembros_struct> }
                         | union <nombre> { <miembros_union> }

<herencia> -> : <visibilidad> <nombre>
                | ε


<visibilidad> -> public | private | protected

<miembros_struct> -> <miembro_struct> <miembros_struct>
                  | ε

<miembro_struct> -> <declaración_func>
                  | <funciónes_struct>
                  | <modificador_visibilidad> <miembro_struct>


<miembros_union> -> <declaración> <miembros_union>
                  | ε

<función_principal> -> int main ( ) { <enunciados> return 0;}

Dentro del main-----------------------------------------------------------------------------------------------

<declaracion_instancia> -> <nombre> <nombre> ;                        
                         | <nombre> <nombre_variable> ( <argumentos> ) ;      
                         | <nombre> <nombre> = <nombre> ( <argumentos> ) ; 


<declaración> ->  <modificador_variable> <tipo> <nombre> ; 
                | <tipo> <nombre> ; 
                | <meta_programación> <tipo> <nombre> ;
                | <modificador_variable> <tipo> <nombre> = <nombre> ; 
                | <tipo> <nombre> = <nombre>; 
                | <meta_programación> <tipo> <nombre> = <nombre>;
                | <modificador_variable> <tipo> <nombre> = <nombre>.<nombre>(<argumentos>); 
                | <tipo> <nombre> = <nombre> = <nombre>.<nombre>(<argumentos>); 
                | <meta_programación> <tipo> <nombre> = <nombre> = <nombre>.<nombre>(<argumentos>);
                | enum <nombre> { <lista_valores> } ;
                | <declaración_tipo>
 

<declaración_tipo> -> <modificador> int <nombre> = <expresion_entero> ;
                    | <modificador> float <nombre> = <expresion_decimal> ;
                    | <modificador> double <nombre> = <expresion_decimal> ;
                    | <modificador> char <nombre> = <expresion_caracter> ;
                    | <modificador> bool <nombre> = <expresion_booleano> ;
                    | <modificador> string <nombre> = <expresion_cadena> ;
                    | <modificador> short <nombre> = <expresion_entero> ;
                    | <modificador> long <nombre> = <expresion_entero> ;
                    | <modificador> signed <nombre> = <expresion_entero> ;

<modificador> -> <meta_programación>
                | <modificador_variable>
                | ε

<expresion_entero> -> <entero>
                   | <entero> <operador_aritmetico> <entero>
                   | ( <entero> <operador_aritmetico> <entero> )

<expresion_decimal> -> <decimal>
                    | <decimal> <operador_aritmetico> <decimal>
                    | ( <decimal> <operador_aritmetico> <decimal> )

<expresion_caracter> -> <caracter>        

<expresion_booleana> -> true
                     | false
                     | <expresion_comparacion_booleana>

<expresion_comparacion_booleana> -> <entero> <operador_relacional> <entero>
                                  | <decimal> <operador_relacional> <decimal>

<expresion_cadena> -> <cadena>         


<lista_valores> -> <valor_enum> , <lista_valores>
                 | <valor_enum>

<valor_enum> -> <nombre>
              | <nombre> = <expresión>

<enunciados> -> <enunciado> <enunciados> 
                | ε

<enunciado> -> <asignación> ; 
                | <entrada> ; 
                | <salida> ; 
                | <selección> 
                | <iteración>  
                | <llamada_función> ; 
                | <switch> 
                | <corrutina> ;
                | goto <nombre> ;
                | <nombre> : <enunciado>
                | throw <expresión> ;
                | try { <enunciados> } catch ( <tipo> <nombre> ) { <enunciados> }
                | <declaración>
                | throw <expresión> ;
                | <bloque_try>

<bloque_try> -> try { <enunciados> } <bloques_catch>
<bloques_catch> -> catch ( <tipo> <nombre> ) { <enunciados> } <bloques_catch>
                 | ε

<asignación> -> <asignación-int>
                <asignación-other>

<asignación-other> -> <nommbre> = <expresiones>;

<asignación-int> -> <nombre>++; 
                | <nombre>--; 
                | ++<nombre> ;
                | --<nombre> ;

<selección> -> if ( <condiciones> ) { <enunciados> } <bloques_else>

<bloques_else> -> else if ( <condiciones> ) { <enunciados> } <bloques_else> 
                | else { <enunciados> } 
                | ε

<iteración> -> while ( <condiciones> ) { <enunciados> } 
            | for ( <declaración> ; <condiciones> ; <asignación-int> ) { <enunciados> }

<condiciones> -> <condición> <operador_relacional> <condición> 
            | <condición> <operador_relacional> <condición> <operador_lógico>

<condición> ->  | <nombre>
                | <entero>
                | <decimal>  
                | <nombre>.<nombre>()
                | <condición> <operador_relacional> <condición> 
                | <condición> <operador_relacional> <condición> <operador_lógico>

<expresiones> -> <expresión> <operador_aritmético> <expresión> 
            | (<expresión> <operador_aritmético> <expresión>)

<expresión> -> <nombre> 
            | <entero>
            | <decimal>
            | nullptr
            | <conversión> <tipo> ( <expresión> ) 
            | <conversión> <tipo> ( <expresión> )
            | <expresión> <operador_aritmético> <expresión> 
            | (<expresión> <operador_aritmético> <expresión>)

<switch> -> switch (<nombre>) { <casos> }

<casos> -> case <tipo_casos> : <enunciados_switch> <casos>
        | default : <enunciados_switch>
        | ε

<tipo_casos> -> <cadena>
                | <entero>
                | <decimal>

<enunciados_switch> -> <enunciado_switch> <enunciados_switch> 
                | ε

<enunciado_switch> -> <asignación> ; 
                | <entrada> ; 
                | <salida> ; 
                | <selección> 
                | <switch>
                | <iteración>  
                | <llamada_función> ; 
                | break ; 
                | continue ;

LLamar a función-------------------------------------------------------------------------------------------------------

<llamada_función> -> <nombre> ( <argumentos> )

<argumentos> -> <expresión> , <argumentos> 
                | <expresión> 
                | ε

Terminales-----------------------------------------------------------------------------------------------------------

<corrutina> -> co_await <expresión> 
             | co_yield <expresión> 
             | co_return <expresión> 

<conversión> -> const_cast
              | dynamic_cast
              | static_cast
              | reinterpret_cast

<meta_programación> -> decltype
                     | constexpr
                     | consteval
                     | constinit

<declarador> -> extern
              | export
              | explicit
              | default
              | enum
              | concept
              | compl

<flujo_control> -> do

<tipo> -> int 
        | float 
        | double 
        | char 
        | string 
        | bool
        | char8_t
        | char16_t
        | char32_t
        | auto 
        | decltype ( <expresión> )
        | short
        | short int
        | long
        | long int
        | signed
        | signed int
        | unsigned int 

<modificador_variable> -> inline 
                        | mutable 
                        | register 
                        | alignas
                        | thread_local
                        | volatile
                        | unsigned

<modificador_funcion>  -> noexcept 
                        | requires 
                        | template 
                        | static_assert
                        | virtual 
        

<nombre> -> identificador

<entero> -> 0...9

<decimal> -> 0..9 . 0...9

<cadena> -> " cualquier texto "

<booleano> = true
            | false

            

<operador_relacional> -> == 
                        | != 
                        | < 
                        | > 
                        | <= 
                        | >=
                        | not_eq

<operador_aritmético> -> + 
                        | - 
                        | * 
                        | /

<operador_lógico> -> && 
                    | ||
                    | not
                    | or
                    | or_eq 

<operador_binario> -> xor_eq
                    | ^=


Entrada--------------------------------------------------------------------------------------------------------------

<entrada> -> scanf ( <cadena> , &<nombre> ) ; 
            | std :: cin >> <nombre> ; 
            | cin >> <nombre> ; 

Imprimir en pantalla------------------------------------------------------------------------------------------------

<salida> -> printf ( <printf_salida> ) ; 
            | std :: cout << <elementos_salida> ; 
            | cout << <elementos_salida> ;

<printfs_salida> -> <printf_salida> << <printfs_salida> 
                | <printf_salida> 


<printf_salida> -> <cadena> 
                | <nombre> 
                | ,

<elementos_salida> -> <elemento_salida> << <elementos_salida> 
                    | <elemento_salida>

<elemento_salida> -> <cadena> 
                   | <nombre>
                   | <nombre>.<nombre>() 
                   | endl 
                   | std :: endl 
                   | <llamada_función>


<cadena_o_variable> -> <cadena> 
                    | <nombre> 
                    | <cadena_o_variable> << <cadena_o_variable>


Despues del main------------------------------------------------------------------------------------------------------------

<funciones> -> <función> <funciones> 
                | ε

<función> -> <tipo_función> <nombre> ( <parámetros> ) { <enunciados_función> <retorno> }
                | <modificador_función> <tipo_función> <nombre> ( <parámetros> ) { <enunciados_función> <retorno> }
                | <declarador> <tipo_función> <nombre> ( <parámetros> ) { <enunciados_función> <retorno>  }

<declaración_func> -> <modificador_variable> <tipo> <nombre> ; 
                | <tipo> <nombre> ; 
                | <meta_programación> <tipo> <nombre> ;
                | <modificador_variable> <tipo> <nombre> = <nombre>.<nombre>(<argumentos>); 
                | <tipo> <nombre> = <nombre> = <nombre>.<nombre>(<argumentos>); 
                | <meta_programación> <tipo> <nombre> = <nombre> = <nombre>.<nombre>(<argumentos>);
                | enum <nombre> { <lista_valores> } ;
                

<lista_valores_func> -> <valor_enum_func> , <lista_valores_func>
                 | <valor_enum_func>

<valor_enum_func> -> <nombre>
              | <nombre> = <expresión_func>

<enunciados_función> -> <enunciado_función> <enunciados_función> 
                | ε

<enunciado_función> -> <asignación_func> ; 
                | <entrada> ; 
                | <salida> ; 
                | <selección> 
                | <iteración>  
                | <llamada_función> ; 
                | <switch_funcion> 
                | <corrutina> ;
                | goto <nombre> ;
                | <nombre> : <enunciado_función>
                | throw <expresión_función> ;
                | try { <enunciados_función> } catch ( <tipo> <nombre> ) { <enunciados_función> }
                | <declaración_func>
                | <declaracion_tipo>
                | throw <expresión_función> ;
                | <bloque_try>

<bloque_try> -> try { <enunciados_función> } <bloques_catch>

<bloques_catch> -> catch ( <tipo> <nombre> ) { <enunciados_funcion> } <bloques_catch>
                 | ε


<parámetros> -> <tipo> <nombre> , <parámetros> 
                | <tipo_funcion> <nombre> | ε

<asignación_func> -> <asignación-int>
                <asignación-other_func>

<asignación-other_func> -> <nommbre> = <expresiones_funcion>;

<tipo_funcion> -> void 
                | int 
                | float 
                | double 
                | char 
                | string 
                | bool

<retorno> -> return <expresión_función> ;
            | ε

<expresiones_funcion> -> <expresión_función> <operador_aritmético> <expresión_función> 
            | (<expresión_función> <operador_aritmético> <expresión_función>)

<expresión_función> -> <nombre> 
            | <entero>
            | <decimal>
            | nullptr
            | <conversión> <tipo> ( <expresión_función> ) 
            | <conversión> <tipo> ( <expresión_función> )
            | <expresión_función> <operador_aritmético> <expresión_función> 
            | (<expresión_función> <operador_aritmético> <expresión_función>)
            | typeid ( <expresión_función> )

<switch_funcion> -> switch (<nombre>) { <casos_función> }

<casos_función> -> case <tipo_casos> : <enunciados_switch_función> <casos>
        | default : <enunciados_switch_función>
        | ε

<enunciados_switch_función> -> <enunciados_switch_función> <enunciados_switch_función> 
                | ε

<enunciados_switch_función> -> <asignación_func> ; 
                | <entrada> ; 
                | <salida> ; 
                | <selección> 
                | <switch_funcion>
                | <iteración>  
                | <llamada_función> ; 
                | break ; 
                | continue ;

Dentro de clases y struct-----------------------------------------------------------------------------------------------------------------

<funciones_struct> -> <función_struct> <funciones_struct> 
                | ε

<función_struct> -> <tipo_función> <nombre> ( <parámetros> ) { <enunciados_struct> <retorno> }
                | <modificador_función> <tipo_función> <nombre> ( <parámetros> ) { <enunciados_struct> <retorno> }
                | <declarador> <tipo_función> <nombre> ( <parámetros> ) { <enunciados_struct> <retorno>  }

<declaración_struct> -> <modificador_variable> <tipo> <nombre> ; 
                | <tipo> <nombre> ; 
                | <meta_programación> <tipo> <nombre> ;
                | <modificador_variable> <tipo> <nombre> = <opciones_struct> ; 
                | <tipo> <nombre> = <opciones_struct>; 
                | <meta_programación> <tipo> <nombre> = <opciones_struct>;
                | <modificador_variable> <tipo> <nombre> = <nombre>.<nombre>(<argumentos>); 
                | <tipo> <nombre> = <nombre> = <nombre>.<nombre>(<argumentos>); 
                | <meta_programación> <tipo> <nombre> = <nombre> = <nombre>.<nombre>(<argumentos>);
                | enum <nombre> { <lista_valores> } ;
                | <constructor> -> <nombre> ( <parámetros> ) { <enunciados_struct> }
                | <destructor> -> ~ <nombre> ( ) { <enunciados_struct> }

                
<opciones_struct> -> this
            | * this
            | this -> <nombre>
            | (* this) . <nombre>
            | <nombre>

<lista_valores_struct> -> <valor_enum_struct> , <lista_valores_struct>
                 | <valor_enum_struct>

<valor_enum_struct> -> <nombre>
              | <nombre> = <expresión_struct>

<enunciados_struct> -> <enunciado_struct> <enunciados_struct> 
                | ε

<enunciado_struct> -> <asignación_struct> ; 
                | <entrada> ; 
                | <salida> ; 
                | <selección> 
                | <iteración>  
                | <llamada_función> ; 
                | <switch_struct> 
                | <corrutina> ;
                | goto <nombre> ;
                | <nombre> : <enunciado_struct
                | throw <expresión_struct> ;
                | try { <enunciados_struct> } catch ( <tipo> <nombre> ) { <enunciados_struct> }
                | <declaración_func>
                | <declaracion_tipo>
                | throw <expresión_struct> ;
                | <bloque_try>

<bloque_try> -> try { <enunciados_struct> } <bloques_catch>

<bloques_catch> -> catch ( <tipo> <nombre> ) { <enunciados_struct> } <bloques_catch>
                 | ε

<asignación_struct> -> <asignación-int>
                <asignación-other_struct>

<asignación-other_struct> -> <nommbre> = <expresiones_struct>;

<retorno> -> return <expresión_struct> ;
            | ε

<expresiones_struct> -> <expresión_struct> <operador_aritmético> <expresión_struct> 
            | (<expresión_struct> <operador_aritmético> <expresión_struct>)

<expresión_struct> -> <nombre> 
            | <entero>
            | <decimal>
            | nullptr
            | <conversión> <tipo> ( <expresión_struct> ) 
            | <conversión> <tipo> ( <expresión_struct> )
            | <expresión_struct> <operador_aritmético> <expresión_struct> 
            | (<expresión_struct> <operador_aritmético> <expresión_struct>)
            | this
            | * this
            | this -> <nombre>
            | (* this) . <nombre>

<switch_struct> -> switch (<nombre>) { <casos_structn> }

<casos_struct> -> case <tipo_casos> : <enunciados_switch_struct> <casos>
        | default : <enunciados_switch_struct>
        | ε

<enunciados_switch_struct> -> <enunciados_switch_struct> <enunciados_switch_struct> 
                | ε

<enunciados_switch_struct> -> <asignación_struct ; 
                | <entrada> ; 
                | <salida> ; 
                | <selección> 
                | <switch_struct>
                | <iteración>  
                | <llamada_struct> ; 
                | break ; 
                | continue ;
